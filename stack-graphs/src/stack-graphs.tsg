;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Stack graphs definition for Solidity
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Global Variables
;; ^^^^^^^^^^^^^^^^

global FILE_PATH
global ROOT_NODE
global JUMP_TO_SCOPE_NODE

;; Attribute Shorthands
;; ^^^^^^^^^^^^^^^^^^^^

attribute node_definition = node        => type = "pop_symbol", node_symbol = node, is_definition
attribute node_reference = node         => type = "push_symbol", node_symbol = node, is_reference
attribute pop_node = node               => type = "pop_symbol", node_symbol = node
attribute pop_scoped_node = node        => type = "pop_scoped_symbol", node_symbol = node
attribute pop_scoped_symbol = symbol    => type = "pop_scoped_symbol", symbol = symbol
attribute pop_symbol = symbol           => type = "pop_symbol", symbol = symbol
attribute push_node = node              => type = "push_symbol", node_symbol = node
attribute push_scoped_node = node       => type = "push_scoped_symbol", node_symbol = node
attribute push_scoped_symbol = symbol   => type = "push_scoped_symbol", symbol = symbol
attribute push_symbol = symbol          => type = "push_symbol", symbol = symbol
attribute scoped_node_definition = node => type = "pop_scoped_symbol", node_symbol = node, is_definition
attribute scoped_node_reference = node  => type = "push_scoped_symbol", node_symbol = node, is_reference
attribute symbol_definition = symbol    => type = "pop_symbol", symbol = symbol, is_definition
attribute symbol_reference = symbol     => type = "push_symbol", symbol = symbol, is_reference

attribute node_symbol = node            => symbol = (source-text node), source_node = node

;; Stack Graph Rules - variable resolution
;; ^^^^^^^^^^^^^^^^^


;; todo - 1: make expression and other nodes public so its possible to make the following rules complete
;; without too much duplicate code
;; todo - 2: stack graph -> member access ( only after todo - 1 )

;;;;;;;;
;; Contracts

;; Introduce lexical scope for contracts
(contract_declaration) @contract {
    node @contract.lexical_scope
    node @contract.lexical_defs
}

;; Contract variables are accessible within contract scope

(contract_declaration
  (_
    (state_variable_declaration)@stmt)) @contract {
    edge @stmt.lexical_scope -> @contract.lexical_scope
    edge @stmt.lexical_scope -> @contract.lexical_defs
}

(contract_declaration
  (_
    (function_definition) @statement)) @contract {
      edge @statement.lexical_scope -> @contract.lexical_scope
      edge @statement.lexical_scope -> @contract.lexical_defs
}

(function_definition body: (function_body (_)@body_stmt))@func {
  edge @body_stmt.lexical_scope -> @func.lexical_scope
  edge @body_stmt.lexical_scope -> @func.lexical_defs
}
;;;;;;;;
;; Statements

(function_body (_)@body_stmt) {
  node @body_stmt.lexical_scope
  node @body_stmt.lexical_defs
}

(function_body (_)@left . (_)@right){
  edge @right.lexical_scope -> @left.lexical_scope
  edge @right.lexical_scope -> @left.lexical_defs

  attr (@right.lexical_scope -> @left.lexical_defs) precedence = 1
}

(state_variable_declaration) @stmt {
  node @stmt.lexical_scope
  node @stmt.lexical_defs
}

(function_definition) @function_def {
  node @function_def.lexical_scope
  node @function_def.lexical_defs
}

(contract_declaration
  (_
    (function_definition name:(identifier) @name) )) @contract {
  node def
  attr(def) node_definition = @name

  edge @contract.lexical_defs -> def
}

(state_variable_declaration name:(identifier) @name ) @variable_declaration {
  node definition
  attr (definition) node_definition = @name

  edge @variable_declaration.lexical_defs -> definition
}


;;;;;;;;
;; expressions

(call_expression) @expr {
  node @expr.lexical_defs
  node @expr.lexical_scope
}

(expression_statement (call_expression) @call_expr) @stmt {
  edge @call_expr.lexical_scope -> @stmt.lexical_scope
  edge @call_expr.lexical_scope -> @stmt.lexical_defs
}

(call_expression function: (identifier)@name ) @expression {
  node reference
  attr (reference) node_reference = @name

  edge reference -> @expression.lexical_scope
}
