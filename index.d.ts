/* tree-sitter-solidity dts autogenerated file */

export interface Parser {
  parse(input: string | Input, previousTree?: Tree, options?: {bufferSize?: number, includedRanges?: Range[]}): Tree;
  getLanguage(): any;
  setLanguage(language: any): void;
  getLogger(): Logger;
  setLogger(logFunc: Logger): void;
}

export type Point = {
  row: number;
  column: number;
};

export type Range = {
  startIndex: number,
  endIndex: number,
  startPosition: Point,
  endPosition: Point
};

export type Edit = {
  startIndex: number;
  oldEndIndex: number;
  newEndIndex: number;
  startPosition: Point;
  oldEndPosition: Point;
  newEndPosition: Point;
};

export type Logger = (
  message: string,
  params: {[param: string]: string},
  type: "parse" | "lex"
) => void;

export interface Input {
  seek(index: number): void;
  read(): any;
}

interface SyntaxNodeBase {
  tree: Tree;
  type: string;
  isNamed: boolean;
  text: string;
  startPosition: Point;
  endPosition: Point;
  startIndex: number;
  endIndex: number;
  parent: SyntaxNode | null;
  children: Array<SyntaxNode>;
  namedChildren: Array<SyntaxNode>;
  childCount: number;
  namedChildCount: number;
  firstChild: SyntaxNode | null;
  firstNamedChild: SyntaxNode | null;
  lastChild: SyntaxNode | null;
  lastNamedChild: SyntaxNode | null;
  nextSibling: SyntaxNode | null;
  nextNamedSibling: SyntaxNode | null;
  previousSibling: SyntaxNode | null;
  previousNamedSibling: SyntaxNode | null;

  hasChanges(): boolean;
  hasError(): boolean;
  isMissing(): boolean;
  toString(): string;
  child(index: number): SyntaxNode | null;
  namedChild(index: number): SyntaxNode | null;
  firstChildForIndex(index: number): SyntaxNode | null;
  firstNamedChildForIndex(index: number): SyntaxNode | null;

  descendantForIndex(index: number): SyntaxNode;
  descendantForIndex(startIndex: number, endIndex: number): SyntaxNode;
  namedDescendantForIndex(index: number): SyntaxNode;
  namedDescendantForIndex(startIndex: number, endIndex: number): SyntaxNode;
  descendantForPosition(position: Point): SyntaxNode;
  descendantForPosition(startPosition: Point, endPosition: Point): SyntaxNode;
  namedDescendantForPosition(position: Point): SyntaxNode;
  namedDescendantForPosition(startPosition: Point, endPosition: Point): SyntaxNode;
  descendantsOfType<T extends TypeString>(types: T | readonly T[], startPosition?: Point, endPosition?: Point): NodeOfType<T>[];

  closest<T extends SyntaxType>(types: T | readonly T[]): NamedNode<T> | null;
  walk(): TreeCursor;
}

export interface TreeCursor {
  nodeType: string;
  nodeText: string;
  nodeIsNamed: boolean;
  startPosition: Point;
  endPosition: Point;
  startIndex: number;
  endIndex: number;
  readonly currentNode: SyntaxNode

  reset(node: SyntaxNode): void
  gotoParent(): boolean;
  gotoFirstChild(): boolean;
  gotoFirstChildForIndex(index: number): boolean;
  gotoNextSibling(): boolean;
}

export interface Tree {
  readonly rootNode: SyntaxNode;

  edit(delta: Edit): Tree;
  walk(): TreeCursor;
  getChangedRanges(other: Tree): Range[];
  getEditedRange(other: Tree): Range;
}

interface NamedNodeBase extends SyntaxNodeBase {
    isNamed: true;
}

/** An unnamed node with the given type string. */
export interface UnnamedNode<T extends string = string> extends SyntaxNodeBase {
  type: T;
  isNamed: false;
}

type PickNamedType<Node, T extends string> = Node extends { type: T; isNamed: true } ? Node : never;

type PickType<Node, T extends string> = Node extends { type: T } ? Node : never;

/** A named node with the given `type` string. */
export type NamedNode<T extends SyntaxType = SyntaxType> = PickNamedType<SyntaxNode, T>;

/**
 * A node with the given `type` string.
 *
 * Note that this matches both named and unnamed nodes. Use `NamedNode<T>` to pick only named nodes.
 */
export type NodeOfType<T extends string> = PickType<SyntaxNode, T>;

interface TreeCursorOfType<S extends string, T extends SyntaxNodeBase> {
  nodeType: S;
  currentNode: T;
}

type TreeCursorRecord = { [K in TypeString]: TreeCursorOfType<K, NodeOfType<K>> };

/**
 * A tree cursor whose `nodeType` correlates with `currentNode`.
 *
 * The typing becomes invalid once the underlying cursor is mutated.
 *
 * The intention is to cast a `TreeCursor` to `TypedTreeCursor` before
 * switching on `nodeType`.
 *
 * For example:
 * ```ts
 * let cursor = root.walk();
 * while (cursor.gotoNextSibling()) {
 *   const c = cursor as TypedTreeCursor;
 *   switch (c.nodeType) {
 *     case SyntaxType.Foo: {
 *       let node = c.currentNode; // Typed as FooNode.
 *       break;
 *     }
 *   }
 * }
 * ```
 */
export type TypedTreeCursor = TreeCursorRecord[keyof TreeCursorRecord];

export interface ErrorNode extends NamedNodeBase {
    type: SyntaxType.ERROR;
    hasError(): true;
}

export const enum SyntaxType {
  ERROR = "ERROR",
  AnySourceType = "any_source_type",
  ArrayAccess = "array_access",
  AssemblyStatement = "assembly_statement",
  AssignmentExpression = "assignment_expression",
  AugmentedAssignmentExpression = "augmented_assignment_expression",
  BinaryExpression = "binary_expression",
  BlockStatement = "block_statement",
  BooleanLiteral = "boolean_literal",
  BreakStatement = "break_statement",
  CallExpression = "call_expression",
  CatchClause = "catch_clause",
  ConstantVariableDeclaration = "constant_variable_declaration",
  ConstructorDefinition = "constructor_definition",
  ContinueStatement = "continue_statement",
  ContractBody = "contract_body",
  ContractDeclaration = "contract_declaration",
  DoWhileStatement = "do_while_statement",
  EmitStatement = "emit_statement",
  EnumDeclaration = "enum_declaration",
  EventDefinition = "event_definition",
  EventParamater = "event_paramater",
  ExpressionStatement = "expression_statement",
  FallbackReceiveDefinition = "fallback_receive_definition",
  False = "false",
  ForStatement = "for_statement",
  FunctionBody = "function_body",
  FunctionDefinition = "function_definition",
  HexStringLiteral = "hex_string_literal",
  IfStatement = "if_statement",
  ImportDirective = "import_directive",
  InheritanceSpecifier = "inheritance_specifier",
  InlineArrayExpression = "inline_array_expression",
  InterfaceDeclaration = "interface_declaration",
  LibraryDeclaration = "library_declaration",
  MemberExpression = "member_expression",
  MetaTypeExpression = "meta_type_expression",
  ModifierDefinition = "modifier_definition",
  ModifierInvocation = "modifier_invocation",
  NewExpression = "new_expression",
  NumberLiteral = "number_literal",
  NumberUnit = "number_unit",
  OverrideSpecifier = "override_specifier",
  Parameter = "parameter",
  ParenthesizedExpression = "parenthesized_expression",
  PayableConversionExpression = "payable_conversion_expression",
  PragmaDirective = "pragma_directive",
  PrimitiveType = "primitive_type",
  ReturnStatement = "return_statement",
  ReturnTypeDefinition = "return_type_definition",
  SliceAccess = "slice_access",
  SourceFile = "source_file",
  StateMutability = "state_mutability",
  StateVariableDeclaration = "state_variable_declaration",
  String = "string",
  StringLiteral = "string_literal",
  StructDeclaration = "struct_declaration",
  StructExpression = "struct_expression",
  StructMember = "struct_member",
  TernaryExpression = "ternary_expression",
  True = "true",
  TryStatement = "try_statement",
  TupleExpression = "tuple_expression",
  TypeAlias = "type_alias",
  TypeCastExpression = "type_cast_expression",
  TypeName = "type_name",
  UnaryExpression = "unary_expression",
  UnicodeStringLiteral = "unicode_string_literal",
  UpdateExpression = "update_expression",
  UsingDirective = "using_directive",
  VariableDeclaration = "variable_declaration",
  VariableDeclarationStatement = "variable_declaration_statement",
  VariableDeclarationTuple = "variable_declaration_tuple",
  Visibility = "visibility",
  WhileStatement = "while_statement",
  YulAssignment = "yul_assignment",
  YulBlock = "yul_block",
  YulBoolean = "yul_boolean",
  YulBreak = "yul_break",
  YulContinue = "yul_continue",
  YulEvmBuiltin = "yul_evm_builtin",
  YulForStatement = "yul_for_statement",
  YulFunctionCall = "yul_function_call",
  YulFunctionDefinition = "yul_function_definition",
  YulIfStatement = "yul_if_statement",
  YulPath = "yul_path",
  YulStringLiteral = "yul_string_literal",
  YulSwitchStatement = "yul_switch_statement",
  YulVariableDeclaration = "yul_variable_declaration",
  Comment = "comment",
  Constant = "constant",
  EnumValue = "enum_value",
  Identifier = "identifier",
  Immutable = "immutable",
  PropertyIdentifier = "property_identifier",
  Virtual = "virtual",
  YulDecimalNumber = "yul_decimal_number",
  YulHexNumber = "yul_hex_number",
  YulIdentifier = "yul_identifier",
  YulLeave = "yul_leave",
}

export type UnnamedType =
  | "!"
  | "!="
  | "!=="
  | "\""
  | "\"evmasm\""
  | "%"
  | "%="
  | "&"
  | "&&"
  | "&="
  | "'"
  | "("
  | ")"
  | "*"
  | "**"
  | "*="
  | "+"
  | "++"
  | "+="
  | ","
  | "-"
  | "--"
  | "-="
  | "->"
  | "."
  | "/"
  | "/="
  | ":"
  | ":="
  | "<"
  | "<<"
  | "<<="
  | "<="
  | "="
  | "=="
  | "=>"
  | ">"
  | ">="
  | ">>"
  | ">>="
  | ">>>"
  | ">>>="
  | "?"
  | "["
  | "]"
  | "^"
  | "^="
  | "_"
  | "abstract"
  | "add"
  | "addmod"
  | "address"
  | "and"
  | "anonymous"
  | "as"
  | "assembly"
  | "balance"
  | "blockhash"
  | "bool"
  | "break"
  | "byte"
  | "bytes"
  | "bytes1"
  | "bytes10"
  | "bytes11"
  | "bytes12"
  | "bytes13"
  | "bytes14"
  | "bytes15"
  | "bytes16"
  | "bytes17"
  | "bytes18"
  | "bytes19"
  | "bytes2"
  | "bytes20"
  | "bytes21"
  | "bytes22"
  | "bytes23"
  | "bytes24"
  | "bytes25"
  | "bytes26"
  | "bytes27"
  | "bytes28"
  | "bytes29"
  | "bytes3"
  | "bytes30"
  | "bytes31"
  | "bytes32"
  | "bytes4"
  | "bytes5"
  | "bytes6"
  | "bytes7"
  | "bytes8"
  | "bytes9"
  | "call"
  | "callcode"
  | "calldata"
  | "calldatacopy"
  | "calldataload"
  | "calldatasize"
  | "caller"
  | "callvalue"
  | "case"
  | "catch"
  | "chainid"
  | "coinbase"
  | "constructor"
  | "continue"
  | "contract"
  | "create"
  | "create2"
  | "days"
  | "default"
  | "delegatecall"
  | "delete"
  | "difficulty"
  | "div"
  | "do"
  | "else"
  | "emit"
  | "enum"
  | "eq"
  | "ether"
  | "event"
  | "exp"
  | "extcodecopy"
  | "extcodehash"
  | "extcodesize"
  | "external"
  | "fallback"
  | SyntaxType.False // both named and unnamed
  | "finney"
  | "fixed"
  | "for"
  | "from"
  | "function"
  | "gas"
  | "gaslimit"
  | "gasprice"
  | "gt"
  | "gwei"
  | "hex"
  | "hours"
  | "if"
  | "import"
  | "indexed"
  | "int"
  | "int104"
  | "int112"
  | "int120"
  | "int128"
  | "int136"
  | "int144"
  | "int152"
  | "int16"
  | "int160"
  | "int168"
  | "int176"
  | "int184"
  | "int192"
  | "int200"
  | "int208"
  | "int216"
  | "int224"
  | "int232"
  | "int24"
  | "int240"
  | "int248"
  | "int256"
  | "int32"
  | "int40"
  | "int48"
  | "int56"
  | "int64"
  | "int72"
  | "int8"
  | "int80"
  | "int88"
  | "int96"
  | "interface"
  | "internal"
  | "invalid"
  | "is"
  | "iszero"
  | "keccak256"
  | "let"
  | "library"
  | "log0"
  | "log1"
  | "log2"
  | "log3"
  | "log4"
  | "lt"
  | "mapping"
  | "memory"
  | "minutes"
  | "mload"
  | "mod"
  | "modifier"
  | "msize"
  | "mstore"
  | "mstore8"
  | "mul"
  | "mulmod"
  | "new"
  | "not"
  | "number"
  | "or"
  | "origin"
  | "override"
  | "payable"
  | "pop"
  | "pragma"
  | "private"
  | "public"
  | "pure"
  | "receive"
  | "return"
  | "returndatacopy"
  | "returndatasize"
  | "returns"
  | "revert"
  | "sar"
  | "sdiv"
  | "seconds"
  | "selfbalance"
  | "selfdestruct"
  | "sgt"
  | "shl"
  | "shr"
  | "signextend"
  | "sload"
  | "slt"
  | "smod"
  | "solidity"
  | "sstore"
  | "staticcall"
  | "stop"
  | "storage"
  | SyntaxType.String // both named and unnamed
  | "struct"
  | "sub"
  | "switch"
  | "szabo"
  | "timestamp"
  | SyntaxType.True // both named and unnamed
  | "try"
  | "type"
  | "ufixed"
  | "uint"
  | "uint104"
  | "uint112"
  | "uint120"
  | "uint128"
  | "uint136"
  | "uint144"
  | "uint152"
  | "uint16"
  | "uint160"
  | "uint168"
  | "uint176"
  | "uint184"
  | "uint192"
  | "uint200"
  | "uint208"
  | "uint216"
  | "uint224"
  | "uint232"
  | "uint24"
  | "uint240"
  | "uint248"
  | "uint256"
  | "uint32"
  | "uint40"
  | "uint48"
  | "uint56"
  | "uint64"
  | "uint72"
  | "uint8"
  | "uint80"
  | "uint88"
  | "uint96"
  | "unicode"
  | "using"
  | "var"
  | "view"
  | "weeks"
  | "wei"
  | "while"
  | "xor"
  | "years"
  | "{"
  | "|"
  | "|="
  | "||"
  | "}"
  | "~"
  ;

export type TypeString = SyntaxType | UnnamedType;

export type SyntaxNode = 
  | AnySourceTypeNode
  | ArrayAccessNode
  | AssemblyStatementNode
  | AssignmentExpressionNode
  | AugmentedAssignmentExpressionNode
  | BinaryExpressionNode
  | BlockStatementNode
  | BooleanLiteralNode
  | BreakStatementNode
  | CallExpressionNode
  | CatchClauseNode
  | ConstantVariableDeclarationNode
  | ConstructorDefinitionNode
  | ContinueStatementNode
  | ContractBodyNode
  | ContractDeclarationNode
  | DoWhileStatementNode
  | EmitStatementNode
  | EnumDeclarationNode
  | EventDefinitionNode
  | EventParamaterNode
  | ExpressionStatementNode
  | FallbackReceiveDefinitionNode
  | FalseNode
  | ForStatementNode
  | FunctionBodyNode
  | FunctionDefinitionNode
  | HexStringLiteralNode
  | IfStatementNode
  | ImportDirectiveNode
  | InheritanceSpecifierNode
  | InlineArrayExpressionNode
  | InterfaceDeclarationNode
  | LibraryDeclarationNode
  | MemberExpressionNode
  | MetaTypeExpressionNode
  | ModifierDefinitionNode
  | ModifierInvocationNode
  | NewExpressionNode
  | NumberLiteralNode
  | NumberUnitNode
  | OverrideSpecifierNode
  | ParameterNode
  | ParenthesizedExpressionNode
  | PayableConversionExpressionNode
  | PragmaDirectiveNode
  | PrimitiveTypeNode
  | ReturnStatementNode
  | ReturnTypeDefinitionNode
  | SliceAccessNode
  | SourceFileNode
  | StateMutabilityNode
  | StateVariableDeclarationNode
  | StringNode
  | StringLiteralNode
  | StructDeclarationNode
  | StructExpressionNode
  | StructMemberNode
  | TernaryExpressionNode
  | TrueNode
  | TryStatementNode
  | TupleExpressionNode
  | TypeAliasNode
  | TypeCastExpressionNode
  | TypeNameNode
  | UnaryExpressionNode
  | UnicodeStringLiteralNode
  | UpdateExpressionNode
  | UsingDirectiveNode
  | VariableDeclarationNode
  | VariableDeclarationStatementNode
  | VariableDeclarationTupleNode
  | VisibilityNode
  | WhileStatementNode
  | YulAssignmentNode
  | YulBlockNode
  | YulBooleanNode
  | YulBreakNode
  | YulContinueNode
  | YulEvmBuiltinNode
  | YulForStatementNode
  | YulFunctionCallNode
  | YulFunctionDefinitionNode
  | YulIfStatementNode
  | YulPathNode
  | YulStringLiteralNode
  | YulSwitchStatementNode
  | YulVariableDeclarationNode
  | UnnamedNode<"!">
  | UnnamedNode<"!=">
  | UnnamedNode<"!==">
  | UnnamedNode<"\"">
  | UnnamedNode<"\"evmasm\"">
  | UnnamedNode<"%">
  | UnnamedNode<"%=">
  | UnnamedNode<"&">
  | UnnamedNode<"&&">
  | UnnamedNode<"&=">
  | UnnamedNode<"'">
  | UnnamedNode<"(">
  | UnnamedNode<")">
  | UnnamedNode<"*">
  | UnnamedNode<"**">
  | UnnamedNode<"*=">
  | UnnamedNode<"+">
  | UnnamedNode<"++">
  | UnnamedNode<"+=">
  | UnnamedNode<",">
  | UnnamedNode<"-">
  | UnnamedNode<"--">
  | UnnamedNode<"-=">
  | UnnamedNode<"->">
  | UnnamedNode<".">
  | UnnamedNode<"/">
  | UnnamedNode<"/=">
  | UnnamedNode<":">
  | UnnamedNode<":=">
  | UnnamedNode<"<">
  | UnnamedNode<"<<">
  | UnnamedNode<"<<=">
  | UnnamedNode<"<=">
  | UnnamedNode<"=">
  | UnnamedNode<"==">
  | UnnamedNode<"=>">
  | UnnamedNode<">">
  | UnnamedNode<">=">
  | UnnamedNode<">>">
  | UnnamedNode<">>=">
  | UnnamedNode<">>>">
  | UnnamedNode<">>>=">
  | UnnamedNode<"?">
  | UnnamedNode<"[">
  | UnnamedNode<"]">
  | UnnamedNode<"^">
  | UnnamedNode<"^=">
  | UnnamedNode<"_">
  | UnnamedNode<"abstract">
  | UnnamedNode<"add">
  | UnnamedNode<"addmod">
  | UnnamedNode<"address">
  | UnnamedNode<"and">
  | UnnamedNode<"anonymous">
  | UnnamedNode<"as">
  | UnnamedNode<"assembly">
  | UnnamedNode<"balance">
  | UnnamedNode<"blockhash">
  | UnnamedNode<"bool">
  | UnnamedNode<"break">
  | UnnamedNode<"byte">
  | UnnamedNode<"bytes">
  | UnnamedNode<"bytes1">
  | UnnamedNode<"bytes10">
  | UnnamedNode<"bytes11">
  | UnnamedNode<"bytes12">
  | UnnamedNode<"bytes13">
  | UnnamedNode<"bytes14">
  | UnnamedNode<"bytes15">
  | UnnamedNode<"bytes16">
  | UnnamedNode<"bytes17">
  | UnnamedNode<"bytes18">
  | UnnamedNode<"bytes19">
  | UnnamedNode<"bytes2">
  | UnnamedNode<"bytes20">
  | UnnamedNode<"bytes21">
  | UnnamedNode<"bytes22">
  | UnnamedNode<"bytes23">
  | UnnamedNode<"bytes24">
  | UnnamedNode<"bytes25">
  | UnnamedNode<"bytes26">
  | UnnamedNode<"bytes27">
  | UnnamedNode<"bytes28">
  | UnnamedNode<"bytes29">
  | UnnamedNode<"bytes3">
  | UnnamedNode<"bytes30">
  | UnnamedNode<"bytes31">
  | UnnamedNode<"bytes32">
  | UnnamedNode<"bytes4">
  | UnnamedNode<"bytes5">
  | UnnamedNode<"bytes6">
  | UnnamedNode<"bytes7">
  | UnnamedNode<"bytes8">
  | UnnamedNode<"bytes9">
  | UnnamedNode<"call">
  | UnnamedNode<"callcode">
  | UnnamedNode<"calldata">
  | UnnamedNode<"calldatacopy">
  | UnnamedNode<"calldataload">
  | UnnamedNode<"calldatasize">
  | UnnamedNode<"caller">
  | UnnamedNode<"callvalue">
  | UnnamedNode<"case">
  | UnnamedNode<"catch">
  | UnnamedNode<"chainid">
  | UnnamedNode<"coinbase">
  | CommentNode
  | ConstantNode
  | UnnamedNode<"constructor">
  | UnnamedNode<"continue">
  | UnnamedNode<"contract">
  | UnnamedNode<"create">
  | UnnamedNode<"create2">
  | UnnamedNode<"days">
  | UnnamedNode<"default">
  | UnnamedNode<"delegatecall">
  | UnnamedNode<"delete">
  | UnnamedNode<"difficulty">
  | UnnamedNode<"div">
  | UnnamedNode<"do">
  | UnnamedNode<"else">
  | UnnamedNode<"emit">
  | UnnamedNode<"enum">
  | EnumValueNode
  | UnnamedNode<"eq">
  | UnnamedNode<"ether">
  | UnnamedNode<"event">
  | UnnamedNode<"exp">
  | UnnamedNode<"extcodecopy">
  | UnnamedNode<"extcodehash">
  | UnnamedNode<"extcodesize">
  | UnnamedNode<"external">
  | UnnamedNode<"fallback">
  | UnnamedNode<SyntaxType.False>
  | UnnamedNode<"finney">
  | UnnamedNode<"fixed">
  | UnnamedNode<"for">
  | UnnamedNode<"from">
  | UnnamedNode<"function">
  | UnnamedNode<"gas">
  | UnnamedNode<"gaslimit">
  | UnnamedNode<"gasprice">
  | UnnamedNode<"gt">
  | UnnamedNode<"gwei">
  | UnnamedNode<"hex">
  | UnnamedNode<"hours">
  | IdentifierNode
  | UnnamedNode<"if">
  | ImmutableNode
  | UnnamedNode<"import">
  | UnnamedNode<"indexed">
  | UnnamedNode<"int">
  | UnnamedNode<"int104">
  | UnnamedNode<"int112">
  | UnnamedNode<"int120">
  | UnnamedNode<"int128">
  | UnnamedNode<"int136">
  | UnnamedNode<"int144">
  | UnnamedNode<"int152">
  | UnnamedNode<"int16">
  | UnnamedNode<"int160">
  | UnnamedNode<"int168">
  | UnnamedNode<"int176">
  | UnnamedNode<"int184">
  | UnnamedNode<"int192">
  | UnnamedNode<"int200">
  | UnnamedNode<"int208">
  | UnnamedNode<"int216">
  | UnnamedNode<"int224">
  | UnnamedNode<"int232">
  | UnnamedNode<"int24">
  | UnnamedNode<"int240">
  | UnnamedNode<"int248">
  | UnnamedNode<"int256">
  | UnnamedNode<"int32">
  | UnnamedNode<"int40">
  | UnnamedNode<"int48">
  | UnnamedNode<"int56">
  | UnnamedNode<"int64">
  | UnnamedNode<"int72">
  | UnnamedNode<"int8">
  | UnnamedNode<"int80">
  | UnnamedNode<"int88">
  | UnnamedNode<"int96">
  | UnnamedNode<"interface">
  | UnnamedNode<"internal">
  | UnnamedNode<"invalid">
  | UnnamedNode<"is">
  | UnnamedNode<"iszero">
  | UnnamedNode<"keccak256">
  | UnnamedNode<"let">
  | UnnamedNode<"library">
  | UnnamedNode<"log0">
  | UnnamedNode<"log1">
  | UnnamedNode<"log2">
  | UnnamedNode<"log3">
  | UnnamedNode<"log4">
  | UnnamedNode<"lt">
  | UnnamedNode<"mapping">
  | UnnamedNode<"memory">
  | UnnamedNode<"minutes">
  | UnnamedNode<"mload">
  | UnnamedNode<"mod">
  | UnnamedNode<"modifier">
  | UnnamedNode<"msize">
  | UnnamedNode<"mstore">
  | UnnamedNode<"mstore8">
  | UnnamedNode<"mul">
  | UnnamedNode<"mulmod">
  | UnnamedNode<"new">
  | UnnamedNode<"not">
  | UnnamedNode<"number">
  | UnnamedNode<"or">
  | UnnamedNode<"origin">
  | UnnamedNode<"override">
  | UnnamedNode<"payable">
  | UnnamedNode<"pop">
  | UnnamedNode<"pragma">
  | UnnamedNode<"private">
  | PropertyIdentifierNode
  | UnnamedNode<"public">
  | UnnamedNode<"pure">
  | UnnamedNode<"receive">
  | UnnamedNode<"return">
  | UnnamedNode<"returndatacopy">
  | UnnamedNode<"returndatasize">
  | UnnamedNode<"returns">
  | UnnamedNode<"revert">
  | UnnamedNode<"sar">
  | UnnamedNode<"sdiv">
  | UnnamedNode<"seconds">
  | UnnamedNode<"selfbalance">
  | UnnamedNode<"selfdestruct">
  | UnnamedNode<"sgt">
  | UnnamedNode<"shl">
  | UnnamedNode<"shr">
  | UnnamedNode<"signextend">
  | UnnamedNode<"sload">
  | UnnamedNode<"slt">
  | UnnamedNode<"smod">
  | UnnamedNode<"solidity">
  | UnnamedNode<"sstore">
  | UnnamedNode<"staticcall">
  | UnnamedNode<"stop">
  | UnnamedNode<"storage">
  | UnnamedNode<SyntaxType.String>
  | UnnamedNode<"struct">
  | UnnamedNode<"sub">
  | UnnamedNode<"switch">
  | UnnamedNode<"szabo">
  | UnnamedNode<"timestamp">
  | UnnamedNode<SyntaxType.True>
  | UnnamedNode<"try">
  | UnnamedNode<"type">
  | UnnamedNode<"ufixed">
  | UnnamedNode<"uint">
  | UnnamedNode<"uint104">
  | UnnamedNode<"uint112">
  | UnnamedNode<"uint120">
  | UnnamedNode<"uint128">
  | UnnamedNode<"uint136">
  | UnnamedNode<"uint144">
  | UnnamedNode<"uint152">
  | UnnamedNode<"uint16">
  | UnnamedNode<"uint160">
  | UnnamedNode<"uint168">
  | UnnamedNode<"uint176">
  | UnnamedNode<"uint184">
  | UnnamedNode<"uint192">
  | UnnamedNode<"uint200">
  | UnnamedNode<"uint208">
  | UnnamedNode<"uint216">
  | UnnamedNode<"uint224">
  | UnnamedNode<"uint232">
  | UnnamedNode<"uint24">
  | UnnamedNode<"uint240">
  | UnnamedNode<"uint248">
  | UnnamedNode<"uint256">
  | UnnamedNode<"uint32">
  | UnnamedNode<"uint40">
  | UnnamedNode<"uint48">
  | UnnamedNode<"uint56">
  | UnnamedNode<"uint64">
  | UnnamedNode<"uint72">
  | UnnamedNode<"uint8">
  | UnnamedNode<"uint80">
  | UnnamedNode<"uint88">
  | UnnamedNode<"uint96">
  | UnnamedNode<"unicode">
  | UnnamedNode<"using">
  | UnnamedNode<"var">
  | UnnamedNode<"view">
  | VirtualNode
  | UnnamedNode<"weeks">
  | UnnamedNode<"wei">
  | UnnamedNode<"while">
  | UnnamedNode<"xor">
  | UnnamedNode<"years">
  | YulDecimalNumberNode
  | YulHexNumberNode
  | YulIdentifierNode
  | YulLeaveNode
  | UnnamedNode<"{">
  | UnnamedNode<"|">
  | UnnamedNode<"|=">
  | UnnamedNode<"||">
  | UnnamedNode<"}">
  | UnnamedNode<"~">
  | ErrorNode
  ;

export interface AnySourceTypeNode extends NamedNodeBase {
  type: SyntaxType.AnySourceType;
}

export interface ArrayAccessNode extends NamedNodeBase {
  type: SyntaxType.ArrayAccess;
  baseNodes: (UnnamedNode<"."> | ArrayAccessNode | AssignmentExpressionNode | AugmentedAssignmentExpressionNode | BinaryExpressionNode | BooleanLiteralNode | CallExpressionNode | HexStringLiteralNode | IdentifierNode | InlineArrayExpressionNode | MemberExpressionNode | MetaTypeExpressionNode | NewExpressionNode | NumberLiteralNode | ParenthesizedExpressionNode | PayableConversionExpressionNode | PrimitiveTypeNode | SliceAccessNode | StringLiteralNode | StructExpressionNode | TernaryExpressionNode | TupleExpressionNode | TypeCastExpressionNode | UnaryExpressionNode | UnicodeStringLiteralNode | UpdateExpressionNode)[];
  indexNodes: (UnnamedNode<"."> | ArrayAccessNode | AssignmentExpressionNode | AugmentedAssignmentExpressionNode | BinaryExpressionNode | BooleanLiteralNode | CallExpressionNode | HexStringLiteralNode | IdentifierNode | InlineArrayExpressionNode | MemberExpressionNode | MetaTypeExpressionNode | NewExpressionNode | NumberLiteralNode | ParenthesizedExpressionNode | PayableConversionExpressionNode | PrimitiveTypeNode | SliceAccessNode | StringLiteralNode | StructExpressionNode | TernaryExpressionNode | TupleExpressionNode | TypeCastExpressionNode | UnaryExpressionNode | UnicodeStringLiteralNode | UpdateExpressionNode)[];
}

export interface AssemblyStatementNode extends NamedNodeBase {
  type: SyntaxType.AssemblyStatement;
}

export interface AssignmentExpressionNode extends NamedNodeBase {
  type: SyntaxType.AssignmentExpression;
  leftNode: ArrayAccessNode | IdentifierNode | MemberExpressionNode | ParenthesizedExpressionNode | TupleExpressionNode;
  rightNodes: (UnnamedNode<"."> | ArrayAccessNode | AssignmentExpressionNode | AugmentedAssignmentExpressionNode | BinaryExpressionNode | BooleanLiteralNode | CallExpressionNode | HexStringLiteralNode | IdentifierNode | InlineArrayExpressionNode | MemberExpressionNode | MetaTypeExpressionNode | NewExpressionNode | NumberLiteralNode | ParenthesizedExpressionNode | PayableConversionExpressionNode | PrimitiveTypeNode | SliceAccessNode | StringLiteralNode | StructExpressionNode | TernaryExpressionNode | TupleExpressionNode | TypeCastExpressionNode | UnaryExpressionNode | UnicodeStringLiteralNode | UpdateExpressionNode)[];
}

export interface AugmentedAssignmentExpressionNode extends NamedNodeBase {
  type: SyntaxType.AugmentedAssignmentExpression;
  leftNode: ArrayAccessNode | IdentifierNode | MemberExpressionNode | TupleExpressionNode;
  rightNodes: (UnnamedNode<"."> | ArrayAccessNode | AssignmentExpressionNode | AugmentedAssignmentExpressionNode | BinaryExpressionNode | BooleanLiteralNode | CallExpressionNode | HexStringLiteralNode | IdentifierNode | InlineArrayExpressionNode | MemberExpressionNode | MetaTypeExpressionNode | NewExpressionNode | NumberLiteralNode | ParenthesizedExpressionNode | PayableConversionExpressionNode | PrimitiveTypeNode | SliceAccessNode | StringLiteralNode | StructExpressionNode | TernaryExpressionNode | TupleExpressionNode | TypeCastExpressionNode | UnaryExpressionNode | UnicodeStringLiteralNode | UpdateExpressionNode)[];
}

export interface BinaryExpressionNode extends NamedNodeBase {
  type: SyntaxType.BinaryExpression;
  leftNodes: (UnnamedNode<"."> | ArrayAccessNode | AssignmentExpressionNode | AugmentedAssignmentExpressionNode | BinaryExpressionNode | BooleanLiteralNode | CallExpressionNode | HexStringLiteralNode | IdentifierNode | InlineArrayExpressionNode | MemberExpressionNode | MetaTypeExpressionNode | NewExpressionNode | NumberLiteralNode | ParenthesizedExpressionNode | PayableConversionExpressionNode | PrimitiveTypeNode | SliceAccessNode | StringLiteralNode | StructExpressionNode | TernaryExpressionNode | TupleExpressionNode | TypeCastExpressionNode | UnaryExpressionNode | UnicodeStringLiteralNode | UpdateExpressionNode)[];
  operatorNode: UnnamedNode<"!="> | UnnamedNode<"!=="> | UnnamedNode<"%"> | UnnamedNode<"&"> | UnnamedNode<"&&"> | UnnamedNode<"*"> | UnnamedNode<"**"> | UnnamedNode<"+"> | UnnamedNode<"-"> | UnnamedNode<"/"> | UnnamedNode<"<"> | UnnamedNode<"<<"> | UnnamedNode<"<="> | UnnamedNode<"=="> | UnnamedNode<">"> | UnnamedNode<">="> | UnnamedNode<">>"> | UnnamedNode<">>>"> | UnnamedNode<"^"> | UnnamedNode<"|"> | UnnamedNode<"||">;
  rightNodes: (UnnamedNode<"."> | ArrayAccessNode | AssignmentExpressionNode | AugmentedAssignmentExpressionNode | BinaryExpressionNode | BooleanLiteralNode | CallExpressionNode | HexStringLiteralNode | IdentifierNode | InlineArrayExpressionNode | MemberExpressionNode | MetaTypeExpressionNode | NewExpressionNode | NumberLiteralNode | ParenthesizedExpressionNode | PayableConversionExpressionNode | PrimitiveTypeNode | SliceAccessNode | StringLiteralNode | StructExpressionNode | TernaryExpressionNode | TupleExpressionNode | TypeCastExpressionNode | UnaryExpressionNode | UnicodeStringLiteralNode | UpdateExpressionNode)[];
}

export interface BlockStatementNode extends NamedNodeBase {
  type: SyntaxType.BlockStatement;
}

export interface BooleanLiteralNode extends NamedNodeBase {
  type: SyntaxType.BooleanLiteral;
}

export interface BreakStatementNode extends NamedNodeBase {
  type: SyntaxType.BreakStatement;
}

export interface CallExpressionNode extends NamedNodeBase {
  type: SyntaxType.CallExpression;
}

export interface CatchClauseNode extends NamedNodeBase {
  type: SyntaxType.CatchClause;
}

export interface ConstantVariableDeclarationNode extends NamedNodeBase {
  type: SyntaxType.ConstantVariableDeclaration;
  nameNode: IdentifierNode;
  typeNode: TypeNameNode;
  valueNodes: (UnnamedNode<"."> | ArrayAccessNode | AssignmentExpressionNode | AugmentedAssignmentExpressionNode | BinaryExpressionNode | BooleanLiteralNode | CallExpressionNode | HexStringLiteralNode | IdentifierNode | InlineArrayExpressionNode | MemberExpressionNode | MetaTypeExpressionNode | NewExpressionNode | NumberLiteralNode | ParenthesizedExpressionNode | PayableConversionExpressionNode | PrimitiveTypeNode | SliceAccessNode | StringLiteralNode | StructExpressionNode | TernaryExpressionNode | TupleExpressionNode | TypeCastExpressionNode | UnaryExpressionNode | UnicodeStringLiteralNode | UpdateExpressionNode)[];
}

export interface ConstructorDefinitionNode extends NamedNodeBase {
  type: SyntaxType.ConstructorDefinition;
  bodyNode: FunctionBodyNode;
}

export interface ContinueStatementNode extends NamedNodeBase {
  type: SyntaxType.ContinueStatement;
}

export interface ContractBodyNode extends NamedNodeBase {
  type: SyntaxType.ContractBody;
}

export interface ContractDeclarationNode extends NamedNodeBase {
  type: SyntaxType.ContractDeclaration;
  bodyNode: ContractBodyNode;
  nameNode: IdentifierNode;
}

export interface DoWhileStatementNode extends NamedNodeBase {
  type: SyntaxType.DoWhileStatement;
}

export interface EmitStatementNode extends NamedNodeBase {
  type: SyntaxType.EmitStatement;
}

export interface EnumDeclarationNode extends NamedNodeBase {
  type: SyntaxType.EnumDeclaration;
  enum_type_nameNode: IdentifierNode;
}

export interface EventDefinitionNode extends NamedNodeBase {
  type: SyntaxType.EventDefinition;
  nameNode: IdentifierNode;
}

export interface EventParamaterNode extends NamedNodeBase {
  type: SyntaxType.EventParamater;
  nameNode?: IdentifierNode;
  typeNode: TypeNameNode;
}

export interface ExpressionStatementNode extends NamedNodeBase {
  type: SyntaxType.ExpressionStatement;
}

export interface FallbackReceiveDefinitionNode extends NamedNodeBase {
  type: SyntaxType.FallbackReceiveDefinition;
  bodyNode?: FunctionBodyNode;
}

export interface FalseNode extends NamedNodeBase {
  type: SyntaxType.False;
}

export interface ForStatementNode extends NamedNodeBase {
  type: SyntaxType.ForStatement;
}

export interface FunctionBodyNode extends NamedNodeBase {
  type: SyntaxType.FunctionBody;
}

export interface FunctionDefinitionNode extends NamedNodeBase {
  type: SyntaxType.FunctionDefinition;
  bodyNode?: FunctionBodyNode;
  function_nameNode: IdentifierNode;
  return_typeNode?: ReturnTypeDefinitionNode;
}

export interface HexStringLiteralNode extends NamedNodeBase {
  type: SyntaxType.HexStringLiteral;
}

export interface IfStatementNode extends NamedNodeBase {
  type: SyntaxType.IfStatement;
}

export interface ImportDirectiveNode extends NamedNodeBase {
  type: SyntaxType.ImportDirective;
  import_aliasNodes: IdentifierNode[];
  import_originNodes: IdentifierNode[];
  sourceNode: StringNode;
}

export interface InheritanceSpecifierNode extends NamedNodeBase {
  type: SyntaxType.InheritanceSpecifier;
  ancestorNodes: (UnnamedNode<"."> | IdentifierNode)[];
  ancestor_argumentsNodes: (UnnamedNode<"("> | UnnamedNode<")"> | UnnamedNode<","> | UnnamedNode<"."> | ArrayAccessNode | AssignmentExpressionNode | AugmentedAssignmentExpressionNode | BinaryExpressionNode | BooleanLiteralNode | CallExpressionNode | HexStringLiteralNode | IdentifierNode | InlineArrayExpressionNode | MemberExpressionNode | MetaTypeExpressionNode | NewExpressionNode | NumberLiteralNode | ParenthesizedExpressionNode | PayableConversionExpressionNode | PrimitiveTypeNode | SliceAccessNode | StringLiteralNode | StructExpressionNode | TernaryExpressionNode | TupleExpressionNode | TypeCastExpressionNode | UnaryExpressionNode | UnicodeStringLiteralNode | UpdateExpressionNode | UnnamedNode<"{"> | UnnamedNode<"}">)[];
}

export interface InlineArrayExpressionNode extends NamedNodeBase {
  type: SyntaxType.InlineArrayExpression;
}

export interface InterfaceDeclarationNode extends NamedNodeBase {
  type: SyntaxType.InterfaceDeclaration;
  bodyNode: ContractBodyNode;
  nameNode: IdentifierNode;
}

export interface LibraryDeclarationNode extends NamedNodeBase {
  type: SyntaxType.LibraryDeclaration;
  bodyNode: ContractBodyNode;
  nameNode: IdentifierNode;
}

export interface MemberExpressionNode extends NamedNodeBase {
  type: SyntaxType.MemberExpression;
  objectNodes: (UnnamedNode<"."> | ArrayAccessNode | AssignmentExpressionNode | AugmentedAssignmentExpressionNode | BinaryExpressionNode | BooleanLiteralNode | CallExpressionNode | HexStringLiteralNode | IdentifierNode | InlineArrayExpressionNode | MemberExpressionNode | MetaTypeExpressionNode | NewExpressionNode | NumberLiteralNode | ParenthesizedExpressionNode | PayableConversionExpressionNode | PrimitiveTypeNode | SliceAccessNode | StringLiteralNode | StructExpressionNode | TernaryExpressionNode | TupleExpressionNode | TypeCastExpressionNode | UnaryExpressionNode | UnicodeStringLiteralNode | UpdateExpressionNode)[];
  propertyNode: PropertyIdentifierNode;
}

export interface MetaTypeExpressionNode extends NamedNodeBase {
  type: SyntaxType.MetaTypeExpression;
}

export interface ModifierDefinitionNode extends NamedNodeBase {
  type: SyntaxType.ModifierDefinition;
  bodyNode?: FunctionBodyNode;
  nameNode: IdentifierNode;
}

export interface ModifierInvocationNode extends NamedNodeBase {
  type: SyntaxType.ModifierInvocation;
}

export interface NewExpressionNode extends NamedNodeBase {
  type: SyntaxType.NewExpression;
}

export interface NumberLiteralNode extends NamedNodeBase {
  type: SyntaxType.NumberLiteral;
}

export interface NumberUnitNode extends NamedNodeBase {
  type: SyntaxType.NumberUnit;
}

export interface OverrideSpecifierNode extends NamedNodeBase {
  type: SyntaxType.OverrideSpecifier;
}

export interface ParameterNode extends NamedNodeBase {
  type: SyntaxType.Parameter;
  nameNode?: IdentifierNode;
  storage_locationNode?: UnnamedNode<"calldata"> | UnnamedNode<"memory"> | UnnamedNode<"storage">;
  typeNode: TypeNameNode;
}

export interface ParenthesizedExpressionNode extends NamedNodeBase {
  type: SyntaxType.ParenthesizedExpression;
}

export interface PayableConversionExpressionNode extends NamedNodeBase {
  type: SyntaxType.PayableConversionExpression;
}

export interface PragmaDirectiveNode extends NamedNodeBase {
  type: SyntaxType.PragmaDirective;
  version_constraintNodes: (UnnamedNode<"<"> | UnnamedNode<"<="> | UnnamedNode<"="> | UnnamedNode<">"> | UnnamedNode<">="> | UnnamedNode<"^"> | UnnamedNode<"~">)[];
}

export interface PrimitiveTypeNode extends NamedNodeBase {
  type: SyntaxType.PrimitiveType;
}

export interface ReturnStatementNode extends NamedNodeBase {
  type: SyntaxType.ReturnStatement;
}

export interface ReturnTypeDefinitionNode extends NamedNodeBase {
  type: SyntaxType.ReturnTypeDefinition;
}

export interface SliceAccessNode extends NamedNodeBase {
  type: SyntaxType.SliceAccess;
  baseNodes: (UnnamedNode<"."> | ArrayAccessNode | AssignmentExpressionNode | AugmentedAssignmentExpressionNode | BinaryExpressionNode | BooleanLiteralNode | CallExpressionNode | HexStringLiteralNode | IdentifierNode | InlineArrayExpressionNode | MemberExpressionNode | MetaTypeExpressionNode | NewExpressionNode | NumberLiteralNode | ParenthesizedExpressionNode | PayableConversionExpressionNode | PrimitiveTypeNode | SliceAccessNode | StringLiteralNode | StructExpressionNode | TernaryExpressionNode | TupleExpressionNode | TypeCastExpressionNode | UnaryExpressionNode | UnicodeStringLiteralNode | UpdateExpressionNode)[];
  fromNodes: (UnnamedNode<"."> | ArrayAccessNode | AssignmentExpressionNode | AugmentedAssignmentExpressionNode | BinaryExpressionNode | BooleanLiteralNode | CallExpressionNode | HexStringLiteralNode | IdentifierNode | InlineArrayExpressionNode | MemberExpressionNode | MetaTypeExpressionNode | NewExpressionNode | NumberLiteralNode | ParenthesizedExpressionNode | PayableConversionExpressionNode | PrimitiveTypeNode | SliceAccessNode | StringLiteralNode | StructExpressionNode | TernaryExpressionNode | TupleExpressionNode | TypeCastExpressionNode | UnaryExpressionNode | UnicodeStringLiteralNode | UpdateExpressionNode)[];
  toNodes: (UnnamedNode<"."> | ArrayAccessNode | AssignmentExpressionNode | AugmentedAssignmentExpressionNode | BinaryExpressionNode | BooleanLiteralNode | CallExpressionNode | HexStringLiteralNode | IdentifierNode | InlineArrayExpressionNode | MemberExpressionNode | MetaTypeExpressionNode | NewExpressionNode | NumberLiteralNode | ParenthesizedExpressionNode | PayableConversionExpressionNode | PrimitiveTypeNode | SliceAccessNode | StringLiteralNode | StructExpressionNode | TernaryExpressionNode | TupleExpressionNode | TypeCastExpressionNode | UnaryExpressionNode | UnicodeStringLiteralNode | UpdateExpressionNode)[];
}

export interface SourceFileNode extends NamedNodeBase {
  type: SyntaxType.SourceFile;
}

export interface StateMutabilityNode extends NamedNodeBase {
  type: SyntaxType.StateMutability;
}

export interface StateVariableDeclarationNode extends NamedNodeBase {
  type: SyntaxType.StateVariableDeclaration;
  nameNode: IdentifierNode;
  typeNode: TypeNameNode;
  valueNodes: (UnnamedNode<"."> | ArrayAccessNode | AssignmentExpressionNode | AugmentedAssignmentExpressionNode | BinaryExpressionNode | BooleanLiteralNode | CallExpressionNode | HexStringLiteralNode | IdentifierNode | InlineArrayExpressionNode | MemberExpressionNode | MetaTypeExpressionNode | NewExpressionNode | NumberLiteralNode | ParenthesizedExpressionNode | PayableConversionExpressionNode | PrimitiveTypeNode | SliceAccessNode | StringLiteralNode | StructExpressionNode | TernaryExpressionNode | TupleExpressionNode | TypeCastExpressionNode | UnaryExpressionNode | UnicodeStringLiteralNode | UpdateExpressionNode)[];
  visibilityNodes: VisibilityNode[];
}

export interface StringNode extends NamedNodeBase {
  type: SyntaxType.String;
}

export interface StringLiteralNode extends NamedNodeBase {
  type: SyntaxType.StringLiteral;
}

export interface StructDeclarationNode extends NamedNodeBase {
  type: SyntaxType.StructDeclaration;
  struct_nameNode: IdentifierNode;
}

export interface StructExpressionNode extends NamedNodeBase {
  type: SyntaxType.StructExpression;
}

export interface StructMemberNode extends NamedNodeBase {
  type: SyntaxType.StructMember;
  nameNode: IdentifierNode;
  typeNode: TypeNameNode;
}

export interface TernaryExpressionNode extends NamedNodeBase {
  type: SyntaxType.TernaryExpression;
}

export interface TrueNode extends NamedNodeBase {
  type: SyntaxType.True;
}

export interface TryStatementNode extends NamedNodeBase {
  type: SyntaxType.TryStatement;
}

export interface TupleExpressionNode extends NamedNodeBase {
  type: SyntaxType.TupleExpression;
}

export interface TypeAliasNode extends NamedNodeBase {
  type: SyntaxType.TypeAlias;
}

export interface TypeCastExpressionNode extends NamedNodeBase {
  type: SyntaxType.TypeCastExpression;
}

export interface TypeNameNode extends NamedNodeBase {
  type: SyntaxType.TypeName;
}

export interface UnaryExpressionNode extends NamedNodeBase {
  type: SyntaxType.UnaryExpression;
  argumentNodes: (UnnamedNode<"."> | ArrayAccessNode | AssignmentExpressionNode | AugmentedAssignmentExpressionNode | BinaryExpressionNode | BooleanLiteralNode | CallExpressionNode | HexStringLiteralNode | IdentifierNode | InlineArrayExpressionNode | MemberExpressionNode | MetaTypeExpressionNode | NewExpressionNode | NumberLiteralNode | ParenthesizedExpressionNode | PayableConversionExpressionNode | PrimitiveTypeNode | SliceAccessNode | StringLiteralNode | StructExpressionNode | TernaryExpressionNode | TupleExpressionNode | TypeCastExpressionNode | UnaryExpressionNode | UnicodeStringLiteralNode | UpdateExpressionNode)[];
  operatorNode: UnnamedNode<"!"> | UnnamedNode<"+"> | UnnamedNode<"-"> | UnnamedNode<"delete"> | UnnamedNode<"~">;
}

export interface UnicodeStringLiteralNode extends NamedNodeBase {
  type: SyntaxType.UnicodeStringLiteral;
}

export interface UpdateExpressionNode extends NamedNodeBase {
  type: SyntaxType.UpdateExpression;
  argumentNodes: (UnnamedNode<"."> | ArrayAccessNode | AssignmentExpressionNode | AugmentedAssignmentExpressionNode | BinaryExpressionNode | BooleanLiteralNode | CallExpressionNode | HexStringLiteralNode | IdentifierNode | InlineArrayExpressionNode | MemberExpressionNode | MetaTypeExpressionNode | NewExpressionNode | NumberLiteralNode | ParenthesizedExpressionNode | PayableConversionExpressionNode | PrimitiveTypeNode | SliceAccessNode | StringLiteralNode | StructExpressionNode | TernaryExpressionNode | TupleExpressionNode | TypeCastExpressionNode | UnaryExpressionNode | UnicodeStringLiteralNode | UpdateExpressionNode)[];
  operatorNode: UnnamedNode<"++"> | UnnamedNode<"--">;
}

export interface UsingDirectiveNode extends NamedNodeBase {
  type: SyntaxType.UsingDirective;
  sourceNode: AnySourceTypeNode | TypeNameNode;
}

export interface VariableDeclarationNode extends NamedNodeBase {
  type: SyntaxType.VariableDeclaration;
  nameNode: IdentifierNode;
}

export interface VariableDeclarationStatementNode extends NamedNodeBase {
  type: SyntaxType.VariableDeclarationStatement;
}

export interface VariableDeclarationTupleNode extends NamedNodeBase {
  type: SyntaxType.VariableDeclarationTuple;
}

export interface VisibilityNode extends NamedNodeBase {
  type: SyntaxType.Visibility;
}

export interface WhileStatementNode extends NamedNodeBase {
  type: SyntaxType.WhileStatement;
}

export interface YulAssignmentNode extends NamedNodeBase {
  type: SyntaxType.YulAssignment;
}

export interface YulBlockNode extends NamedNodeBase {
  type: SyntaxType.YulBlock;
}

export interface YulBooleanNode extends NamedNodeBase {
  type: SyntaxType.YulBoolean;
}

export interface YulBreakNode extends NamedNodeBase {
  type: SyntaxType.YulBreak;
}

export interface YulContinueNode extends NamedNodeBase {
  type: SyntaxType.YulContinue;
}

export interface YulEvmBuiltinNode extends NamedNodeBase {
  type: SyntaxType.YulEvmBuiltin;
}

export interface YulForStatementNode extends NamedNodeBase {
  type: SyntaxType.YulForStatement;
}

export interface YulFunctionCallNode extends NamedNodeBase {
  type: SyntaxType.YulFunctionCall;
  functionNode: YulEvmBuiltinNode | YulIdentifierNode;
}

export interface YulFunctionDefinitionNode extends NamedNodeBase {
  type: SyntaxType.YulFunctionDefinition;
}

export interface YulIfStatementNode extends NamedNodeBase {
  type: SyntaxType.YulIfStatement;
}

export interface YulPathNode extends NamedNodeBase {
  type: SyntaxType.YulPath;
}

export interface YulStringLiteralNode extends NamedNodeBase {
  type: SyntaxType.YulStringLiteral;
}

export interface YulSwitchStatementNode extends NamedNodeBase {
  type: SyntaxType.YulSwitchStatement;
}

export interface YulVariableDeclarationNode extends NamedNodeBase {
  type: SyntaxType.YulVariableDeclaration;
  leftNodes: (UnnamedNode<"("> | UnnamedNode<")"> | UnnamedNode<","> | YulIdentifierNode)[];
  rightNode?: YulBooleanNode | YulDecimalNumberNode | YulFunctionCallNode | YulHexNumberNode | YulPathNode | YulStringLiteralNode;
}

export interface CommentNode extends NamedNodeBase {
  type: SyntaxType.Comment;
}

export interface ConstantNode extends NamedNodeBase {
  type: SyntaxType.Constant;
}

export interface EnumValueNode extends NamedNodeBase {
  type: SyntaxType.EnumValue;
}

export interface IdentifierNode extends NamedNodeBase {
  type: SyntaxType.Identifier;
}

export interface ImmutableNode extends NamedNodeBase {
  type: SyntaxType.Immutable;
}

export interface PropertyIdentifierNode extends NamedNodeBase {
  type: SyntaxType.PropertyIdentifier;
}

export interface VirtualNode extends NamedNodeBase {
  type: SyntaxType.Virtual;
}

export interface YulDecimalNumberNode extends NamedNodeBase {
  type: SyntaxType.YulDecimalNumber;
}

export interface YulHexNumberNode extends NamedNodeBase {
  type: SyntaxType.YulHexNumber;
}

export interface YulIdentifierNode extends NamedNodeBase {
  type: SyntaxType.YulIdentifier;
}

export interface YulLeaveNode extends NamedNodeBase {
  type: SyntaxType.YulLeave;
}
